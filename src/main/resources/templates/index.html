<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>ãªãŠã•ã‚“è¡¨æƒ…ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿</title>
<style>
body {
	margin: 0;
	overflow: hidden;
}

#ui {
	position: absolute;
	top: 10px;
	left: 10px;
	background: #fff;
	padding: 10px;
	max-height: 90vh;
	overflow-y: auto;
}

.category {
	margin-bottom: 10px;
	border: 1px solid #ccc;
	padding: 5px;
}

.category>h3 {
	margin: 0;
	cursor: pointer;
	user-select: none;
}

.category .sliders {
	display: none;
	margin-top: 5px;
}

label {
	display: block;
	margin-bottom: 5px;
}

/* ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ */
#resetBtn {
	position: absolute;
	top: 20px;
	right: 20px;
	z-index: 10;
	padding: 5px 10px;
}

#randomBtn {
	position: absolute;
	top: 20px;
	right: 140px; /* ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ã®å¹… + é–“éš”åˆ† */
	z-index: 10;
	padding: 5px 10px;
}

/* ç¾åœ¨å€¤è¡¨ç¤º */
#currentValues {
	position: absolute;
	top: 60px;
	right: 20px;
	max-width: 200px;
	background: #f0f0f0;
	padding: 5px;
	font-size: 14px;
	white-space: pre-line;
}

/*ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒœã‚¿ãƒ³*/
#captureBtn {
	position: absolute;
	bottom: 120px; /* ãƒªã‚»ãƒƒãƒˆ: 20px, Twitter: 180px ã®é–“ã«é…ç½® */
	right: 20px;
	z-index: 10;
	padding: 5px 10px;
}

/* Twitterãƒœã‚¿ãƒ³ */
#shareButton {
	position: absolute;
	bottom: 40px;
	right: 20px;
	background-color: #1DA1F2;
	color: white;
	border: none;
	padding: 10px 20px;
	font-size: 30px;
	cursor: pointer;
	border-radius: 5px;
}

#shareButton:hover {
	background-color: #0d95e8;
}

#shareButton:active {
	background-color: #0a7bbf;
}
</style>
</head>
<body>

	<div id="ui"></div>
	<button id="resetBtn">è¡¨æƒ…ãƒªã‚»ãƒƒãƒˆ</button>
	<div id="currentValues"></div>
	<button id="captureBtn">ã‚­ãƒ£ãƒ—ãƒãƒ£ä¿å­˜</button>
	<button id="shareButton">Twitterã§ã‚·ã‚§ã‚¢</button>
	<button id="randomBtn">ãƒ©ãƒ³ãƒ€ãƒ è¡¨æƒ…</button>

	<script type="module">
import * as THREE from "https://esm.sh/three@0.173.0";
import { GLTFLoader } from "https://esm.sh/three@0.173.0/examples/jsm/loaders/GLTFLoader.js";
import { VRM, VRMLoaderPlugin, VRMUtils } from "https://esm.sh/@pixiv/three-vrm@3.4.2?deps=three@0.173.0";

const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(15, window.innerWidth / window.innerHeight, 0.1, 1000);
camera.position.set(0, 1.5, 3);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0x000000, 0);
document.body.appendChild(renderer.domElement);

// DirectionalLightï¼ˆå½±ã‚‚å‡ºã—ãŸã„å ´åˆï¼‰
const light = new THREE.DirectionalLight(0xffffff, 1);
light.position.set(0, 1.5, 1);       // ã‚«ãƒ¡ãƒ©ã‚ˆã‚Šæ‰‹å‰ã«é…ç½®
light.target.position.set(0, 1.5, 0); // é¡”ã®æ–¹å‘ã‚’å‘ã
scene.add(light);
scene.add(light.target);

// PointLightï¼ˆé¡”å…¨ä½“ã‚’æŸ”ã‚‰ã‹ãç…§ã‚‰ã™ï¼‰
const pointLight = new THREE.PointLight(0xffffff, 1);
pointLight.position.set(0, 1.5, 1); // é¡”ã®å‰
scene.add(pointLight);

const loader = new GLTFLoader();
loader.register(parser => new VRMLoaderPlugin(parser));

let vrm;
let isVRM1 = false;
const ui = document.getElementById("ui");
const currentValuesDiv = document.getElementById("currentValues");

// ã‚«ãƒ†ã‚´ãƒªãƒ«ãƒ¼ãƒ«
const categories = {
    "ç›®": ["ã¾ã°ãŸã","ã‚¦ã‚£ãƒ³ã‚¯","ï½³ï½¨ï¾ï½¸","ç³","ç›®","ãªã¬","ã¯ã…","ã­ã‚‹","ã³ã£ãã‚Š","ç¬‘ã„","ã‚ãŠã‚Š","ãªã”ã¿"],
    "å£": ["å£","ã‚","ã„","ã†","ãˆ","ãŠ","vrc.v_","ã¡ã‡ã£","ã¨ã˜","ã‚€ãã‚Œã‚‹","ã‚€ã£","ã‚ˆã ã‚Œ","æ¨ªé•·","ç„¦ã‚Š","Ï‰","Ï‰â–¡","Ï‰ä¸­","Ï‰å¤§","Ï‰å¤§_ãƒ‰ãƒ¤","âˆ§","â–²","ã¯ã‚“ã£ï¼","ãºã‚ã£","æ­¯","ã«ã‚„ã‚Š","èˆŒ"],
    "é ¬": ["ã»ã£ãº","é ¬æŸ“ã‚","é’ã–ã‚"],
    "æ¶™": ["æ¶™","å·¦ä¸Š","å³ä¸Š","å·¦ä¸‹","å³ä¸‹"],
    "çœ‰æ¯›": ["æ€’ã‚Š","å›°ã‚‹","ä¸Š","ä¸‹","çœŸé¢ç›®","ã«ã“ã‚Š"]
};
const classificationPriority = ["å‰Šé™¤äºˆå®š","å£","æ¶™", "çœ‰æ¯›", "ç›®",  "é ¬"];
const uiOrder = ["çœ‰æ¯›", "ç›®", "å£", "é ¬", "æ¶™"];

loader.load("/models/Na0_6.vrm", (gltf) => {
    vrm = gltf.userData.vrm;
    VRMUtils.combineSkeletons(vrm.scene);
    scene.add(vrm.scene);

    const extensions = gltf.parser.json.extensionsUsed || [];
    if (extensions.includes("VRMC_vrm")) isVRM1 = true;
    else if (extensions.includes("VRM")) isVRM1 = false;

    const meshes = ["Body","Body_1","Body_2","Body_3","Body_4","Body_5","Body_6"];
    const blendShapeNames = new Set();
    meshes.forEach(meshName => {
        const mesh = vrm.scene.getObjectByName(meshName);
        if (mesh?.morphTargetDictionary) Object.keys(mesh.morphTargetDictionary).forEach(name => blendShapeNames.add(name));
    });

    const assignedNames = new Set();
    const categoryContainers = {};
    const sliderElements = {}; // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼è¦ç´ ã‚’ä¿å­˜

    // UIç”Ÿæˆ
    uiOrder.forEach(catName => {
        const categoryDiv = document.createElement("div");
        categoryDiv.className = "category";

        const h3 = document.createElement("h3");
        h3.textContent = catName;
        categoryDiv.appendChild(h3);

        const slidersDiv = document.createElement("div");
        slidersDiv.className = "sliders";
        categoryDiv.appendChild(slidersDiv);

        h3.addEventListener("click", () => {
            slidersDiv.style.display = slidersDiv.style.display === "none" ? "block" : "none";
        });

        categoryContainers[catName] = slidersDiv;
        ui.appendChild(categoryDiv);
    });

    // ãã®ä»–
    const otherDiv = document.createElement("div");
    otherDiv.className = "category";
    const otherH3 = document.createElement("h3");
    otherH3.textContent = "ãã®ä»–";
    otherDiv.appendChild(otherH3);
    const otherSliders = document.createElement("div");
    otherSliders.className = "sliders";
    otherDiv.appendChild(otherSliders);
    otherH3.addEventListener("click", () => {
        otherSliders.style.display = otherSliders.style.display === "none" ? "block" : "none";
    });
    ui.appendChild(otherDiv);


const exceptionCategoryMap = {
    "ä¸¸ç›®_æ¶™": "ç›®",
	"ä¸¸ç›®_æ¶™2": "ç›®",
    // å¿…è¦ãªã‚‰ã“ã“ã«è¿½åŠ 
};

    // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ç”Ÿæˆ
blendShapeNames.forEach(name => {
    if (assignedNames.has(name)) return;

    // ã¾ãšä¾‹å¤–ãƒãƒƒãƒ—ã§ã‚«ãƒ†ã‚´ãƒªã‚’æ±ºå®š
    let assignedCategory = exceptionCategoryMap[name];

    const toDelete = ["ã«ã£ã“ã‚Š", "é ¬æŸ“ã‚_A","é ¬æŸ“ã‚_B","ã¨ã˜ã‚‹è‚Œ"];
    if (!assignedCategory) {  // ä¾‹å¤–ãƒãƒƒãƒ—ã«ç„¡ã‘ã‚Œã°é€šå¸¸ãƒ«ãƒ¼ãƒ«
        if (toDelete.includes(name)) assignedCategory = "å‰Šé™¤äºˆå®š";
        else {
            for (const catName of classificationPriority) {
                const keywords = categories[catName];
                if (keywords && keywords.includes(name)) { assignedCategory = catName; break; }
            }
            // åå‰ã«ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ãŒå«ã¾ã‚Œã‚‹å ´åˆ
            if (!assignedCategory || assignedCategory === "ãã®ä»–") {
                for (const catName of classificationPriority) {
                    const keywords = categories[catName];
                    if (keywords && keywords.some(kw => name.includes(kw))) { assignedCategory = catName; break; }
                }
            }
        }
    }

    // æœ€å¾Œã«æ±ºã¾ã‚‰ãªã‘ã‚Œã° "ãã®ä»–"
    if (!assignedCategory) assignedCategory = "ãã®ä»–";

    assignedNames.add(name);

    if (assignedCategory !== "å‰Šé™¤äºˆå®š") {
        const label = document.createElement("label");
        label.textContent = name;
        const input = document.createElement("input");
        input.type = "range";
        input.min = 0;
        input.max = 1;
        input.step = 0.01;
        input.value = 0;
        label.appendChild(input);

        // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼å¤‰æ›´æ™‚ã«VRMæ›´æ–°ï¼†ç¾åœ¨å€¤è¡¨ç¤ºæ›´æ–°
        input.addEventListener("input", e => {
            const val = parseFloat(e.target.value);
            meshes.forEach(meshName => {
                const mesh = vrm.scene.getObjectByName(meshName);
                if (!mesh || !mesh.morphTargetDictionary || !mesh.morphTargetInfluences) return;
                const index = mesh.morphTargetDictionary[name];
                if (index !== undefined) mesh.morphTargetInfluences[index] = val;
            });
            if (isVRM1 && vrm.expressionManager && vrm.expressionManager.expressions[name]) {
                vrm.expressionManager.setValue(name, val);
                vrm.expressionManager.update();
            }
            updateCurrentValues();
        });

        const container = categoryContainers[assignedCategory] || otherSliders;
        container.appendChild(label);

        sliderElements[name] = input; // ä¿å­˜
    }
});

    // ç¾åœ¨å€¤æ›´æ–°é–¢æ•°
    function updateCurrentValues() {
        const texts = [];
        for (const [name, input] of Object.entries(sliderElements)) {
            const val = parseFloat(input.value);
            if (val > 0) texts.push(`${name}: ${val.toFixed(2)}`);
        }
        currentValuesDiv.textContent = texts.join("\n");
    }

    // ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³
    document.getElementById("resetBtn").addEventListener("click", () => {
        for (const input of Object.values(sliderElements)) input.value = 0;
        meshes.forEach(meshName => {
            const mesh = vrm.scene.getObjectByName(meshName);
            if (!mesh || !mesh.morphTargetInfluences) return;
            Object.keys(mesh.morphTargetDictionary).forEach(name => {
                const index = mesh.morphTargetDictionary[name];
                if (index !== undefined) mesh.morphTargetInfluences[index] = 0;
 updateCurrentValues();
            });
        });
        if (isVRM1 && vrm.expressionManager) vrm.expressionManager.resetAll();
        setTimeout(updateCurrentValues, 50);
    });

//ã‚­ãƒ£ãƒ—ãƒãƒ£ãƒœã‚¿ãƒ³
document.getElementById("captureBtn").addEventListener("click", () => {
    renderer.render(scene, camera);
    const dataURL = renderer.domElement.toDataURL("image/png");
    const a = document.createElement("a");
    a.href = dataURL;
    a.download = "naosan_capture.png";
    a.click();
});


    // Twitterãƒœã‚¿ãƒ³
    document.getElementById("shareButton").addEventListener("click", () => {
        const texts = [];
        for (const [name, input] of Object.entries(sliderElements)) {
            const val = parseFloat(input.value);
            if (val > 0) texts.push(`${name}: ${val.toFixed(2)}`);
        }
        const tweetText = "ğŸŒ±ãªãŠã•ã‚“è¡¨æƒ…ã‚¸ã‚§ãƒãƒ¬ãƒ¼ã‚¿ã§ä½œæˆã—ã¾ã—ãŸï¼ğŸŒ±\n\nã€ãƒ¬ã‚·ãƒ”ã€‘\n" + texts.join("\n");
        const tweetUrl = `https://twitter.com/intent/tweet?text=${encodeURIComponent(tweetText)}`;
        window.open(tweetUrl, "_blank", "width=550,height=420");
    });

// ãƒ©ãƒ³ãƒ€ãƒ è¡¨æƒ…ãƒœã‚¿ãƒ³
document.getElementById("randomBtn").addEventListener("click", () => {

// --- ã¾ãšãƒªã‚»ãƒƒãƒˆ ---
    for (const input of Object.values(sliderElements)) input.value = 0;
    const meshes = ["Body","Body_1","Body_2","Body_3","Body_4","Body_5","Body_6"];
    meshes.forEach(meshName => {
        const mesh = vrm.scene.getObjectByName(meshName);
        if (!mesh || !mesh.morphTargetInfluences) return;
        Object.keys(mesh.morphTargetDictionary).forEach(name => {
            const index = mesh.morphTargetDictionary[name];
            if (index !== undefined) mesh.morphTargetInfluences[index] = 0;
        });
    });

    const targetCategories = ["çœ‰æ¯›", "ç›®", "å£", "é ¬", "æ¶™"];
	const excludeList = ["ç³å¤§", "ç›®ãªã—","ç™½ç›®","ä¸¸ç›®2","ç³å°"]

    targetCategories.forEach(randomCategory => {
        // é¸ã‚“ã ã‚«ãƒ†ã‚´ãƒªå†…ã®ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’å–å¾—
        const slidersInCategory = [];
        for (const [name, input] of Object.entries(sliderElements)) {
            const parentDiv = input.closest(".sliders");
            if (parentDiv && parentDiv.parentElement.querySelector("h3").textContent === randomCategory && !excludeList.includes(name)) {
                slidersInCategory.push(input);
            }
        }

        if (slidersInCategory.length === 0) return;

        // ãƒ©ãƒ³ãƒ€ãƒ ã«1ã¤é¸ã‚“ã§ONï¼ˆå€¤1ã«ï¼‰
        const randomSlider = slidersInCategory[Math.floor(Math.random() * slidersInCategory.length)];
        randomSlider.value = 1;

        // VRMã«åæ˜ 
        const name = randomSlider.parentElement.textContent;
        const val = parseFloat(randomSlider.value);
        const meshes = ["Body","Body_1","Body_2","Body_3","Body_4","Body_5","Body_6"];
        meshes.forEach(meshName => {
            const mesh = vrm.scene.getObjectByName(meshName);
            if (!mesh || !mesh.morphTargetDictionary || !mesh.morphTargetInfluences) return;
            const index = mesh.morphTargetDictionary[name];
            if (index !== undefined) mesh.morphTargetInfluences[index] = val;
        });
        if (isVRM1 && vrm.expressionManager && vrm.expressionManager.expressions[name]) {
            vrm.expressionManager.setValue(name, val);
            vrm.expressionManager.update();
        }
    });

    // ç¾åœ¨å€¤è¡¨ç¤ºã‚‚æ›´æ–°
    updateCurrentValues();
});

});

window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});

function animate() {
    requestAnimationFrame(animate);
    if (vrm) vrm.update(0.016);
    renderer.render(scene, camera);
}
animate();
</script>

</body>
</html>
